+++
id = "TASK-ARCH-250509153800"
title = "Phase 1: Pac-Man Game - Research Rendering Tech & Define Architecture"
status = "üü¢ Done" # Updated: Research complete, ADR created, Arch defined.
type = "üí° Spike/Research"
priority = "üîº High"
created_date = "2025-05-09"
updated_date = "2025-05-09" # Will be updated by system, but good to note change
# due_date = ""
timebox = "0.5 day" # Actual time taken
assigned_to = "core-architect"
# reporter = "roo-commander"
parent_task = "SESSION-Implement_PacMan_Game-2505091530"
# depends_on = []
related_docs = ["docs/test_requests/pacman.md", ".ruru/decisions/ADR-PACMAN-RENDERING-001.md"] # Added ADR
tags = ["pacman", "research", "architecture", "rendering", "webgl", "canvas", "nextjs", "phaserjs", "pixijs", "adr"] # Added ADR tag
template_schema_doc = ".ruru/templates/toml-md/06_mdtm_spike.README.md"
outcome = "PixiJS selected as the rendering technology. High-level architecture defined."
recommendation = "Proceed with PixiJS for rendering. See ADR-PACMAN-RENDERING-001.md for details."
evaluated_options = ["Phaser.js", "PixiJS", "Vanilla Canvas/WebGL"]
# ai_prompt_log = """MCP tools were attempted but failed, research was manual based on search results.""" # Updated
# reviewed_by = ""
key_learnings = "PixiJS offers a good balance of performance, flexibility, and integration capability with Next.js/TypeScript for this project. Full game engines might be overkill, and vanilla WebGL too complex for the given scope."
+++

# Research Rendering Technology & Define High-Level Architecture for Pac-Man Game

## Description ‚úçÔ∏è

*   **What is the research question or goal?**
    *   Determine the most suitable rendering technology (e.g., Phaser.js, PixiJS, vanilla Canvas with WebGL, or other relevant libraries/frameworks) for developing the Pac-Man web game, considering the project requirements (Next.js, TypeScript, specified features like shooting, dynamic ghosts).
    *   Define a high-level architecture for the game, outlining major components and their interactions.
*   **Why is this research needed?**
    *   The choice of rendering technology is a foundational architectural decision that will significantly impact development complexity, performance, and feature implementation.
    *   A clear high-level architecture is needed to guide subsequent development phases.
*   **Scope:**
    *   Evaluate at least 2-3 promising rendering options.
    *   Consider ease of integration with Next.js and TypeScript.
    *   Assess performance implications for a 2D game with moderate complexity.
    *   Consider community support, documentation, and learning curve.
    *   Outline core game modules (e.g., Game Loop, Input Handler, State Manager, Rendering Engine, Collision Detection, Entity Manager for Pac-Man/Ghosts/Pellets/Projectiles).
*   **Timebox:** (core-architect to define, suggest 1-2 days)

## Acceptance Criteria (Definition of Done) ‚úÖ

*   - [‚úÖ] A recommended rendering technology is selected with clear justification.
*   - [‚úÖ] An Architecture Decision Record (ADR) for the rendering technology choice is created in `.ruru/decisions/` (using template [`07_adr.md`](.ruru/templates/toml-md/07_adr.md:1)). (See [`ADR-PACMAN-RENDERING-001.md`](../decisions/ADR-PACMAN-RENDERING-001.md))
*   - [‚úÖ] A high-level architecture document/diagram (can be part of the ADR or a separate artifact linked here) is produced, outlining key components and their interactions. (See "High-Level Architecture" section below)
*   - [‚úÖ] The pros and cons of the evaluated rendering options are documented. (See [`ADR-PACMAN-RENDERING-001.md`](../decisions/ADR-PACMAN-RENDERING-001.md))
*   - [‚úÖ] Potential risks or challenges associated with the chosen technology and architecture are identified. (See [`ADR-PACMAN-RENDERING-001.md`](../decisions/ADR-PACMAN-RENDERING-001.md))

## Implementation Notes / Research Approach üìù

*   Reviewed project requirements in [`docs/test_requests/pacman.md`](docs/test_requests/pacman.md).
*   Researched popular 2D web game rendering libraries/engines compatible with Next.js/TypeScript (Phaser.js, PixiJS, Vanilla Canvas/WebGL) using Brave Search due to MCP tool issues.
*   Consulted online resources, tutorials, and community discussions.
*   MCP tools (`vertex-ai-mcp-server`, `brave-search`) were attempted but encountered connection/API issues. Research was conducted based on web search results.

## Findings / Results üìä

*   **Phaser.js:** A comprehensive 2D game framework.
    *   **Pros:** Rich feature set (physics, input, asset loading, state management), good for rapid development, strong TypeScript support, large community.
    *   **Cons:** Can be overkill if only a subset of features is needed. Its opinionated structure might be less flexible for deep integration into a Next.js app where a custom component-based approach is desired.
*   **PixiJS:** A fast and flexible 2D WebGL rendering engine.
    *   **Pros:** High performance, excellent TypeScript support, good for integration with frameworks like Next.js, provides rendering primitives allowing for custom game logic architecture, active community.
    *   **Cons:** Primarily a renderer; game logic (state, physics, detailed collision) needs to be built or integrated with other libraries.
*   **Vanilla HTML5 Canvas / WebGL:** Using browser native APIs directly.
    *   **Pros:** Maximum control, potentially highest performance if optimized correctly, no external rendering dependencies.
    *   **Cons:** Significantly higher development effort and complexity. Requires implementing all rendering abstractions from scratch. Steeper learning curve.

## Recommendation / Conclusion üí°

*   **Recommended Technology:** PixiJS.
*   **Justification:** PixiJS offers the best balance for this project. It provides the performance benefits of WebGL and integrates well with the Next.js/TypeScript stack. It's more flexible than a full engine like Phaser.js if we want to build custom game logic modules, and significantly less complex than using vanilla WebGL. This choice allows for a modular architecture where PixiJS handles rendering, and other game systems can be developed independently.
*   The detailed justification and comparison are documented in [`ADR-PACMAN-RENDERING-001.md`](../decisions/ADR-PACMAN-RENDERING-001.md).

## High-Level Architecture (using PixiJS)

The proposed high-level architecture consists of the following main modules:

*   **Next.js Application Shell:**
    *   Manages overall page structure, UI elements outside the game (e.g., score display, start/pause buttons using React components, potentially Shadcn UI).
    *   Hosts the PixiJS canvas.
*   **Game Core Module:**
    *   **Game Controller/Manager:** Orchestrates game flow, manages game states (loading, playing, paused, game over), initializes/coordinates other modules.
    *   **Game Loop:** Central timing mechanism (PixiJS `Ticker` or custom `requestAnimationFrame`). Updates game logic, triggers rendering.
    *   **Input Handler:** Captures user inputs (keyboard) for game actions.
    *   **State Manager (Game State):** Manages score, lives, level, ammo, power-up status, entity states.
    *   **Asset Loader (PixiJS based):** Loads images, spritesheets, sound effects.
*   **Rendering Module (PixiJS based):**
    *   **Renderer:** Initializes and manages PixiJS Application/Renderer and Stage.
    *   **Entity Renderer:** Renders game entities (Pac-Man, Ghosts, Pellets, Projectiles, Maze) using PixiJS display objects.
*   **Game Logic Module:**
    *   **Entity Manager:** Manages all game entities (creation, update, removal).
        *   *PacMan Entity:* Movement, shooting, state logic.
        *   *Ghost Entities:* AI (movement, chasing, fleeing, respawning).
        *   *Pellet Entities:* Logic for pellets and power pellets.
        *   *Projectile Entities:* Logic for Pac-Man's projectiles.
    *   **Collision Detection:** Detects interactions between game entities and maze walls.
    *   **Maze/Level Manager:** Defines and manages maze structure, wall placements, pellet locations.
    *   **Rules Engine (Implicit/Explicit):** Enforces game rules (scoring, lives, level progression, power-up effects).
*   **TypeScript Types/Interfaces:**
    *   Define clear types for all game entities, states, and module interactions.

**Key Interactions:**
1.  Next.js App initializes Game Core.
2.  Game Controller initializes other modules. Asset Loader loads assets.
3.  Input Handler sends actions to Game Controller/Entities.
4.  Game Loop updates entities (via Entity Manager), checks collisions, updates State Manager.
5.  Rendering Module (PixiJS) draws the current game state.
6.  State Manager updates UI in Next.js App.

## AI Prompt Log ü§ñ (Optional)

*   Initial research attempts using `vertex-ai-mcp-server` and `brave-search` MCP tools failed due to server/API key issues.
*   Subsequent `brave-search` calls were successful and provided initial links for Phaser.js, PixiJS, and Vanilla Canvas/WebGL.
*   The analysis and comparison were performed based on these search results and general architectural knowledge.

## Review Notes üëÄ (For Reviewer)

*   (Space for feedback from roo-commander or others)

## Key Learnings üí° (Optional - Fill upon completion)

*   (core-architect to summarize discoveries)
## Log Entries ü™µ

*   (Logs will be appended here when no active session log is specified)
